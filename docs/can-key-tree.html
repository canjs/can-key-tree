<!DOCTYPE html>

<html>
<head>
  <title>can-key-tree.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>can-key-tree.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> reflect = <span class="hljs-built_in">require</span>( <span class="hljs-string">"can-reflect"</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>
<p>The following implement helper functions useful to <code>can-key-tree</code>‘s main methods.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h3 id="isbuiltinprototype">isBuiltInPrototype</h3>
<p>Returns if <code>obj</code> is the prototype of a built-in JS type like <code>Map</code>.
Built in types’ <code>toString</code> returns <code>[object TYPENAME]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBuiltInPrototype</span> (<span class="hljs-params"> obj </span>) </span>{
	<span class="hljs-keyword">if</span> ( obj === <span class="hljs-built_in">Object</span>.prototype ) {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	<span class="hljs-keyword">var</span> protoString = <span class="hljs-built_in">Object</span>.prototype.toString.call( obj );
	<span class="hljs-keyword">var</span> isNotObjObj = protoString !== <span class="hljs-string">'[object Object]'</span>;
	<span class="hljs-keyword">var</span> isObjSomething = protoString.indexOf( <span class="hljs-string">'[object '</span> ) !== <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">return</span> isNotObjObj &amp;&amp; isObjSomething;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h3 id="getdeepsize">getDeepSize</h3>
<p>Recursively returns the number of leaf values below <code>root</code> node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDeepSize</span> (<span class="hljs-params"> root, level </span>) </span>{
	<span class="hljs-keyword">if</span> ( level === <span class="hljs-number">0</span> ) {
		<span class="hljs-keyword">return</span> reflect.size( root );
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( reflect.size( root ) === <span class="hljs-number">0</span> ) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
		reflect.each( root, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
			count += getDeepSize( value, level - <span class="hljs-number">1</span> );
		});
		<span class="hljs-keyword">return</span> count;
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3 id="getdeep">getDeep</h3>
<p>Adds all leaf values under <code>node</code> to <code>items</code>.
<code>depth</code> is how deep <code>node</code> is in the tree.
<code>maxDepth</code> is the total depth of the tree structure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDeep</span> (<span class="hljs-params"> node, items, depth, maxDepth </span>) </span>{
	<span class="hljs-keyword">if</span> ( !node ) {
		<span class="hljs-keyword">return</span>;
	}
	<span class="hljs-keyword">if</span> ( maxDepth === depth ) {
		<span class="hljs-keyword">if</span> ( reflect.isMoreListLikeThanMapLike( node ) ) {
			reflect.addValues( items, reflect.toArray( node ) );
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"can-key-tree: Map-type leaf containers are not supported yet."</span> );
		}
	} <span class="hljs-keyword">else</span> {
		reflect.each( node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value </span>) </span>{
			getDeep( value, items, depth + <span class="hljs-number">1</span>, maxDepth );
		});
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3 id="cleardeep">clearDeep</h3>
<p>Recursively removes value from all child nodes of <code>node</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearDeep</span> (<span class="hljs-params"> node, depth, maxDepth </span>) </span>{
	<span class="hljs-keyword">if</span> ( maxDepth === depth ) {
		<span class="hljs-keyword">if</span> ( reflect.isMoreListLikeThanMapLike( node ) ) {
			reflect.removeValues( node, reflect.toArray( node ) );
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"can-key-tree: Map-type leaf containers are not supported yet."</span> );
		}
	} <span class="hljs-keyword">else</span> {
		reflect.each( node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> value, key </span>) </span>{
			clearDeep( value, depth+<span class="hljs-number">1</span>, maxDepth );
			reflect.deleteKeyValue( node, key );
		});
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="keytree">KeyTree</h2>
<p>Creates an instance of the KeyTree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> KeyTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> treeStructure, callbacks </span>) </span>{
	<span class="hljs-keyword">this</span>.callbacks = callbacks || {};

	<span class="hljs-keyword">this</span>.treeStructure = treeStructure;
	<span class="hljs-keyword">var</span> FirstConstructor = treeStructure[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">if</span> ( reflect.isConstructorLike( FirstConstructor ) ) {
		<span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> FirstConstructor();
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">this</span>.root = FirstConstructor;
	}
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="methods">Methods</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>reflect.assign(KeyTree.prototype,{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h3 id="add">Add</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> keys </span>) </span>{
    	<span class="hljs-keyword">if</span> ( keys.length &gt; <span class="hljs-keyword">this</span>.treeStructure.length ) {
    		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"can-key-tree: Can not add path deeper than tree."</span> );
    	}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The place we will add the final leaf value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">var</span> place = <span class="hljs-keyword">this</span>.root;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Record if the root was empty so we know to call <code>onFirst</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">var</span> rootWasEmpty = reflect.size( <span class="hljs-keyword">this</span>.root ) === <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>For each key, try to get the corresponding childNode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length - <span class="hljs-number">1</span>; i++ ) {
    		<span class="hljs-keyword">var</span> key = keys[i];
    		<span class="hljs-keyword">var</span> childNode = reflect.getKeyValue( place, key );
    		<span class="hljs-keyword">if</span> ( !childNode ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>If there is no childNode, create it and add it to the parent node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    			<span class="hljs-keyword">var</span> Constructor = <span class="hljs-keyword">this</span>.treeStructure[i + <span class="hljs-number">1</span>];
    			<span class="hljs-keyword">if</span> ( isBuiltInPrototype( Constructor.prototype ) ) {
    				childNode = <span class="hljs-keyword">new</span> Constructor();
    			} <span class="hljs-keyword">else</span> {
    				childNode = <span class="hljs-keyword">new</span> Constructor( key );
    			}
    			reflect.setKeyValue( place, key, childNode );
    		}
    		place = childNode;
    	}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Add the final leaf value in the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">if</span> ( reflect.isMoreListLikeThanMapLike( place ) ) {
    		reflect.addValues( place, [keys[keys.length - <span class="hljs-number">1</span>]] );
    	} <span class="hljs-keyword">else</span> {
    		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"can-key-tree: Map types are not supported yet."</span> );
    	}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Callback <code>onFirst</code> if appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">if</span> ( rootWasEmpty &amp;&amp; <span class="hljs-keyword">this</span>.callbacks.onFirst ) {
    		<span class="hljs-keyword">this</span>.callbacks.onFirst.call( <span class="hljs-keyword">this</span> );
    	}

    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h3 id="getnode">getNode</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    getNode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> keys </span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.root;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>For each key, try to read the child node.
If a child is not found, return <code>undefined</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++ ) {
            <span class="hljs-keyword">var</span> key = keys[i];
            node = reflect.getKeyValue( node, key );
            <span class="hljs-keyword">if</span> ( !node ) {
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-keyword">return</span> node;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h3 id="get">get</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> keys </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Get the node specified by keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.getNode( keys );</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>If it’s a leaf, return it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.treeStructure.length === keys.length ) {
    		<span class="hljs-keyword">return</span> node;
    	} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Otherwise, create a container for leaf values and
recursively walk the node’s children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    		<span class="hljs-keyword">var</span> Type = <span class="hljs-keyword">this</span>.treeStructure[<span class="hljs-keyword">this</span>.treeStructure.length - <span class="hljs-number">1</span>];
    		<span class="hljs-keyword">var</span> items = <span class="hljs-keyword">new</span> Type();
    		getDeep( node, items, keys.length, <span class="hljs-keyword">this</span>.treeStructure.length - <span class="hljs-number">1</span> );
    		<span class="hljs-keyword">return</span> items;
    	}
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h3 id="delete">delete</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">delete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> keys </span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><code>parentNode</code> will eventually be the parent nodde of the
node specified by keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> parentNode = <span class="hljs-keyword">this</span>.root,</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>The nodes traversed to the node specified by <code>keys</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            path = [<span class="hljs-keyword">this</span>.root],
            lastKey = keys[keys.length - <span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Set parentNode to the node specified by keys
and record the nodes in <code>path</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length - <span class="hljs-number">1</span>; i++ ) {
    		<span class="hljs-keyword">var</span> key = keys[i];
    		<span class="hljs-keyword">var</span> childNode = reflect.getKeyValue( parentNode, key );
    		<span class="hljs-keyword">if</span> ( childNode === <span class="hljs-literal">undefined</span> ) {
    			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    		} <span class="hljs-keyword">else</span> {
    			path.push( childNode );
    		}
    		parentNode = childNode;
    	}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Depending on which keys were specified and the content of the
key, do various cleanups …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( !keys.length ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>If there are no keys, recursively clear the entire tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    		clearDeep( parentNode, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.treeStructure.length - <span class="hljs-number">1</span> );
    	}
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( keys.length === <span class="hljs-keyword">this</span>.treeStructure.length ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>If removing a leaf, remove that value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    		<span class="hljs-keyword">if</span> ( reflect.isMoreListLikeThanMapLike( parentNode ) ) {
    			reflect.removeValues( parentNode, [lastKey] );
    		} <span class="hljs-keyword">else</span> {
    			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"can-key-tree: Map types are not supported yet."</span> );
    		}
    	}
        <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>If removing a node ‘within’ the tree, recursively clear
that node and then delete the key from parent to node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> nodeToRemove = reflect.getKeyValue( parentNode, lastKey );
    		<span class="hljs-keyword">if</span> ( nodeToRemove !== <span class="hljs-literal">undefined</span> ) {
    			clearDeep( nodeToRemove, keys.length, <span class="hljs-keyword">this</span>.treeStructure.length - <span class="hljs-number">1</span> );
    			reflect.deleteKeyValue( parentNode, lastKey );
    		} <span class="hljs-keyword">else</span> {
    			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    		}
    	}</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>After deleting the node, check if its parent is empty and
recursively prune parent nodes that are now empty.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">for</span> ( i = path.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- ) {
    		<span class="hljs-keyword">if</span> ( reflect.size( parentNode ) === <span class="hljs-number">0</span> ) {
    			parentNode = path[i];
    			reflect.deleteKeyValue( parentNode, keys[i] );
    		} <span class="hljs-keyword">else</span> {
    			<span class="hljs-keyword">break</span>;
    		}
    	}</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Call <code>onEmpty</code> if the tree is now empty.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.callbacks.onEmpty &amp;&amp; reflect.size( <span class="hljs-keyword">this</span>.root ) === <span class="hljs-number">0</span> ) {
    		<span class="hljs-keyword">this</span>.callbacks.onEmpty.call( <span class="hljs-keyword">this</span> );
    	}
    	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h3 id="size">size</h3>
<p>Recursively count the number of leaf values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    size: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    	<span class="hljs-keyword">return</span> getDeepSize( <span class="hljs-keyword">this</span>.root, <span class="hljs-keyword">this</span>.treeStructure.length - <span class="hljs-number">1</span> );
    }
});

<span class="hljs-built_in">module</span>.exports = KeyTree;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
